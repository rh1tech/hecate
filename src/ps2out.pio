;
; Hecate - PS/2 PIO Program
;
; Single PIO state machine for bidirectional PS/2 communication.
; Handles both device-to-host TX and host-to-device RX in the same SM.
;
; This PIO program is derived from ps2x2pico by No0ne.
;
; Copyright (c) 2024 No0ne (https://github.com/No0ne)
;           (c) 2023 Dustin Hoffman
;
; Pin mapping:
;   - dat: PS/2 DATA line
;   - dat+1 (clk): PS/2 CLK line
;   - set pins: CLK (pindirs control)
;   - sideset: DATA (pindirs control)
;   - out pins: DATA
;   - in pins: DATA
;   - jmp pin: CLK
;
; Clock divider: 320 gives 2.5µs per instruction at 125MHz
;
; SPDX-License-Identifier: MIT
;

.program ps2out
.side_set 1 opt pindirs

restart:
    set    pindirs, 0             [1] ; set clock to input mode (high-z, pulled high)
    irq    clear 0 rel     side 0     ; clear busy flag, set data to input mode

receivecheck:
    jmp    pin, sendcheck             ; if clock is high, see if we have data to send
    irq    nowait 0 rel               ; clock is being pulled low, set busy flag
    wait   1 pin, 1                   ; wait for clock to be pulled high

    ; We are not sending, look for a start bit (clock high, data low)
    in     pins, 1                    ; read in from data
    mov    x, isr                     ; move what we read to x
    mov    isr, null                  ; clear ISR
    jmp    !x, receive                ; if x is low, start the receive process
    jmp    restart                    ; not receiving

receive:
    set    x, 8                   [7] ; set loop counter
    set    pindirs, 1             [7] ; clock low

receiveloop:
    set    pindirs, 0             [7] ; clock high
    in     pins, 1                [6] ; read a bit into ISR
    set    pindirs, 1             [6] ; clock low
    jmp    x--, receiveloop       [6] ; iterate
    set    pindirs, 0             [7] ; clock high
    nop                    side 1 [6] ; data low (ACK)
    set    pindirs, 1             [7] ; clock low
    jmp    restart                [5]

sendcheck:
    jmp    !osre, send                ; see if we have data to send
    jmp    receivecheck               ; no data to send, restart

send:
    irq    nowait 0 rel               ; set busy flag
    set    x, 10                      ; number of bits to write out

sendloop:
    set    pindirs, 0             [5] ; clock set to input (high)
    jmp    pin, sendcontinue          ; if clock is high, host is still receiving data
    out    null, 32                   ; clock was low, clear OSR
    irq    wait 4 rel                 ; host wants to send data, notify of failure
    jmp    restart                    ; and wait for restart

sendcontinue:
    out    pindirs, 1             [5] ; write out data via pindirs (0=high-z/high, 1=low)
    set    pindirs, 1             [5] ; set clock low
    jmp    x--, sendloop          [5]


% c-sdk {

static inline void ps2out_program_init_ex(PIO pio, uint sm, uint offset, uint dat, uint clk) {
    pio_sm_config c = ps2out_program_get_default_config(offset);

    pio_gpio_init(pio, clk);
    pio_gpio_init(pio, dat);

    // PS/2 is open-drain, needs pull-ups
    gpio_pull_up(clk);
    gpio_pull_up(dat);
    
    // Use a frequency high enough to effectively sample clock and data
    // 125MHz / 320 = 390.625kHz = 2.56µs per instruction
    sm_config_set_clkdiv(&c, 320);
    
    sm_config_set_jmp_pin(&c, clk);
    sm_config_set_set_pins(&c, clk, 1);
    sm_config_set_sideset_pins(&c, dat);
    sm_config_set_out_pins(&c, dat, 1);
    sm_config_set_out_shift(&c, true, true, 11);
    sm_config_set_in_pins(&c, dat);
    sm_config_set_in_shift(&c, true, true, 9);
    
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

static inline void ps2out_program_init(PIO pio, uint sm, uint offset, uint dat) {
    ps2out_program_init_ex(pio, sm, offset, dat, dat + 1);
}

%}
